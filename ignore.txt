#include "raylib.h"
#include "raymath.h"
#define RLIGHTS_IMPLEMENTATION
#include "rlights.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <omp.h>


/* 
 * 200 x 500 x 100 
 * Chunk size 50
 * */
#define WORLD_H 200
#define WORLD_W 500
#define WORLD_Z 500
#define CHUNK_SIZE 100

#define DIV1 300
#define DIV2 500

#if defined(PLATFORM_DESKTOP)
    #define GLSL_VERSION            330
#else   // PLATFORM_RPI, PLATFORM_ANDROID, PLATFORM_WEB
    #define GLSL_VERSION            100
#endif



int randRange(int range){
	return (rand() % (range + 1));
}
double dist(double x1, double y1, double x2, double y2){
	return sqrt((y2-y1)*(y2-y1) + (x2-x1)*(x2-x1));
}



int calcMesh3D(float size, char ***arr, int cX, int cY, int cZ, int cXW, int cYW, int cZW, Mesh cube, Material matDefault, Matrix *m){

		int mI = 0;
		
		//m = (Matrix*)RL_CALLOC(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE, sizeof(Matrix));
		
		Vector3 axis = (Vector3){ 0, 0, 0 };
		float angle = 0;
		Matrix rotation = MatrixRotate(axis, angle);

		
		//printf("%d\n", tid);
		
		#pragma omp parallel shared (arr)
		{
			int localmI = 0;
			int skip = 1;
			Matrix *localM = (Matrix*)RL_CALLOC(CHUNK_SIZE * CHUNK_SIZE * CHUNK_SIZE / 7, sizeof(Matrix));
			
			
			int tid = omp_get_thread_num();
			int num_threads = omp_get_num_threads();
			int localI;
			
			//printf("%d\n", tid);
			//printf("%d\n", num_threads);
			int i, j, k;
			for(i = cY+cYW; i >= cY; i-=1){
			
				if(i == WORLD_H)
					continue;
				for(j = cX; j < cX+cXW; j+=skip){
					int kskip = num_threads;
						if(j > 300 || kskip == 10*num_threads){
							skip = 10;
						}
						else {
							skip = 1;
						}
					

					if(j <= 300){
						for(k = tid+cZ; k < 300; k+=kskip){
						
							char curr = 0;
							curr = arr[i][j][k];
							
							if(curr == 1){
								//DrawCube((Vector3){j*size + offsetX, i*size + offsetY, k*size}, size, size, size, GRAY);
							}
							else if(curr == 2){
								if(!(i-1 >= 0 && arr[i-1][j][k] == 2)){
									Matrix translation = MatrixTranslate(j*size, -i*size + WORLD_H*size, k*size);
									localM[localmI] = MatrixMultiply(rotation, translation);
									localmI++;
									
								}
							}
							else if(curr == 3){
								//DrawCube((Vector3){j*size + offsetX, i*size + offsetY, k*size}, size, size, size, BLUE);
							}
							else {
								//DrawRectangle(j*size + offsetX, i*size + offsetY, size, size, SKYBLUE);
								//DrawRectangleLines(i*size + offsetX, j*size+offsetY, size, size, BLACK);
								
							}
						
						}
						kskip = 10*num_threads;
						for(k = 300+tid*10; k < cZW; k+=kskip){
						
							char curr = 0;
							curr = arr[i][j][k];
							
							if(curr == 1){
								//DrawCube((Vector3){j*size + offsetX, i*size + offsetY, k*size}, size, size, size, GRAY);
							}
							else if(curr == 2){
								if(!(i-1 >= 0 && arr[i-1][j][k] == 2)){
									Matrix translation = MatrixTranslate(j*size, -i*size + WORLD_H*size, k*size);
									localM[localmI] = MatrixMultiply(rotation, translation);
									localmI++;
									
								}
							}
							else if(curr == 3){
								//DrawCube((Vector3){j*size + offsetX, i*size + offsetY, k*size}, size, size, size, BLUE);
							}
							else {
								//DrawRectangle(j*size + offsetX, i*size + offsetY, size, size, SKYBLUE);
								//DrawRectangleLines(i*size + offsetX, j*size+offsetY, size, size, BLACK);
								
							}
						
						}
					
					}
					else {
						kskip = 10*num_threads;
						skip = 10;
						for(k = tid*10; k < cZW; k+=kskip){
						
							char curr = 0;
							curr = arr[i][j][k];
							
							if(curr == 1){
								//DrawCube((Vector3){j*size + offsetX, i*size + offsetY, k*size}, size, size, size, GRAY);
							}
							else if(curr == 2){
								if(!(i-1 >= 0 && arr[i-1][j][k] == 2)){
									Matrix translation = MatrixTranslate(j*size, -i*size + WORLD_H*size, k*size);
									localM[localmI] = MatrixMultiply(rotation, translation);
									localmI++;
									
								}
							}
							else if(curr == 3){
								//DrawCube((Vector3){j*size + offsetX, i*size + offsetY, k*size}, size, size, size, BLUE);
							}
							else {
								//DrawRectangle(j*size + offsetX, i*size + offsetY, size, size, SKYBLUE);
								//DrawRectangleLines(i*size + offsetX, j*size+offsetY, size, size, BLACK);
								
							}
						
						}
					}
				}
			}
			
			//#pragma omp barrier
			#pragma omp critical 
			{
				
				for(int i = 0; i < localmI; i++){
					m[mI] = localM[i];
					mI++;
				}
				
			}
			
			RL_FREE(localM);
			
			

		}
		//printf("%d\n", mI);
		//DrawMeshInstanced(cube, matDefault, m, mI);
		return mI;
		//RL_FREE(m);
		//free(m);
	
}


int testAdj(int i, int j, int k, int w, int h, int d, char ***arr, int moves, int type){
	int options = moves;
	int dir = randRange(options-1);
	int placed = 0;
	int sDir = -1;
	while(placed != 1){
		//Fail condition: OOB or all options have been exhausted
		if(dir == sDir || i+1 >= h){
			placed = 1;
			return 0;
			break;
		}//Attempt right
		if(dir == 0){
			//Element into air
			if(j-1 >= 0 && arr[i+1][j-1][k] == 0){
				arr[i][j][k] = 0;
				arr[i+1][j-1][k] = type;
				placed = 1;
				return 1;
			} // Sand into water
			else if(j-1 >= 0 && arr[i+1][j-1][k] == 3 && type == 2){
				arr[i][j][k] = 3;
				arr[i+1][j-1][k] = type;
				placed = 1;
				return 1;
			}
			else if(j-1 < 0){
				placed = 1;
			}
		}//Attempt Left
		if(dir == 1){
			//Element into air
			if(j+1 < w && arr[i+1][j+1][k] == 0){
				arr[i][j][k] = 0;
				arr[i+1][j+1][k] = type;
				placed = 1;
				return 1;
			} //Sand into water
			else if(j+1 < w && arr[i+1][j+1][k] == 3 && type == 2){
				arr[i][j][k] = 3;
				arr[i+1][j+1][k] = type;
				placed = 1;
				return 1;
			}
			else if(j+1 >= w){
				placed = 1;
			}
		}
		//Attempt backwards
		if(dir == 2){
			//Element into air
			if(k-1 >= 0 && arr[i+1][j][k-1] == 0){
				arr[i][j][k] = 0;
				arr[i+1][j][k-1] = type;
				placed = 1;
				return 1;
			} // Sand into water
			else if(k-1 >= 0 && arr[i+1][j][k-1] == 3 && type == 2){
				arr[i][j][k] = 3;
				arr[i+1][j][k-1] = type;
				placed = 1;
				return 1;
			}
			else if(k-1 < 0){
				placed = 1;
			}
		}
		//Attempt forwards
		if(dir == 3){
			//Element into air
			if(k+1 < d && arr[i+1][j][k+1] == 0){
				arr[i][j][k] = 0;
				arr[i+1][j][k+1] = type;
				placed = 1;
				return 1;
			} //Sand into water
			else if(k+1 < d && arr[i+1][j][k+1] == 3 && type == 2){
				arr[i][j][k] = 3;
				arr[i+1][j][k+1] = type;
				placed = 1;
				return 1;
			}
			else if(k+1 >= d){
				placed = 1;
			}
		}
		
		//If current direction fails attempt next direction
		if(sDir == -1)
			sDir = dir;
		dir++;
		if(dir >= options){
			dir = 0;
		}
		
	}
	return 0;
}

void updateGrid(int cX, int cY, int cZ, int w, int h, int d, char ***arr, char ***chunks){
	int i, j, k, v;
	int updated = 0;
	
	for(i = cY*CHUNK_SIZE+CHUNK_SIZE-1; i >= cY*CHUNK_SIZE; i--){
		for(j = cX*CHUNK_SIZE; j < cX*CHUNK_SIZE+CHUNK_SIZE; j++){
			for(k = cZ*CHUNK_SIZE; k < cZ*CHUNK_SIZE+CHUNK_SIZE; k++){
				//Sand
				if(arr[i][j][k] == 2){
					//Downward into air
					if(i+1 < h && arr[i+1][j][k] == 0){
						arr[i][j][k] = 0;
						arr[i+1][j][k] = 2;
						updated = 1;
						

					} //Downward into water
					else if(i+1 < h && arr[i+1][j][k] == 3){
						arr[i][j][k]=3;
						arr[i+1][j][k] = 2;
						updated = 1;
						
					} //Diagonal search
					else{
						v = testAdj(i, j, k, w, h, d, arr, 4, 2);
						if(v == 1){
							updated = 1;
							
						}
						
					}
				}//Water 

				/*
				else if(arr[i][j] == 3){
					//Downward into air
					if(i+1 < h && arr[i+1][j] == 0){
						arr[i][j] = 0;
						arr[i+1][j] = 3;
						updated = 1;
					}
					else {
						//Attempt diagonal motion
						v = testAdj(i, j, w, h, arr, 2, 3);
						if(v == 0){
							//If diagonal fails attempt left/right motion
							if(j+1 < w && arr[i][j+1] == 0){
								arr[i][j] = 0;
								arr[i][j+1] = 3;
								updated = 1;
							}
							else if(j-1 >= 0 && arr[i][j-1] == 0){
								arr[i][j] = 0;
								arr[i][j-1] = 3;
								updated = 1;
							}
						}
						else {
							updated = 1;
						}
					}
				}
				*/


			}
		}
	}

	if(updated == 1){
		//printf("updating\n");
		
		for(i = cY-1; i <= cY+1; i++){
			for(j = cX-1; j <= cX+1; j++){
				for(k = cZ-1; k <= cZ+1; k++){
					//printf("%d\n", WORLD_W/CHUNK_SIZE);
					if(i >= 0 && i < WORLD_H/CHUNK_SIZE && j >= 0 && j < WORLD_W/CHUNK_SIZE && k>=0 && k < WORLD_Z/CHUNK_SIZE){
						//if(chunks[i][j] != 1){	
						chunks[i][j][k] = 1;
						//}
					}	
				}
			}
		}
		
			
	}
	else {
		
		chunks[cY][cX][cZ] = 0;
		
	}
}


//Random brush
void rainBrush(char ***grid, char ***chunks){
	int x, y, z, r;
	for(y = 0; y < WORLD_H; y++){
		for(x = 0; x < WORLD_W; x++){
			for(z = 0; z < WORLD_Z; z++){
				r = randRange(155);
				if(r == 1){
					grid[y][x][z] = 2;
					chunks[(int)floor(y / CHUNK_SIZE)][(int)floor(x/CHUNK_SIZE)][(int)floor(z/CHUNK_SIZE)] = 1;
				}
				else {
					grid[y][x][z] = 0;
				}
			}
		}
	}
}



int main(void){
	int brushMode = 1;
	const int screenWidth = 1280;
	const int screenHeight = 720;
	int offsetX = 100;
	int offsetY = 20;
	float blockSize = 0.1f;
	int chunkSize = 50;

	//char grid[WORLD_H][WORLD_W][WORLD_Z] = {0};
	
	char ***grid = calloc(WORLD_H, sizeof(char**));
	for (int i = 0; i < WORLD_H; i++) {
		
    	grid[i] = calloc(WORLD_W , sizeof(char*));
	}
	for (int i = 0; i < WORLD_H; i++) {
		for(int j = 0; j < WORLD_W; j++){
    		grid[i][j] = calloc(WORLD_Z , sizeof(char));
		}
	}

	//char chunks[WORLD_H/CHUNK_SIZE][WORLD_W/CHUNK_SIZE][WORLD_Z/CHUNK_SIZE] = {0};
	char ***chunks = calloc(WORLD_H/CHUNK_SIZE , sizeof(char**));
	for (int i = 0; i < WORLD_H/CHUNK_SIZE; i++) {
		
    	chunks[i] = calloc(WORLD_W/CHUNK_SIZE , sizeof(char*));
	}
	for (int i = 0; i < WORLD_H/CHUNK_SIZE; i++) {
		for(int j = 0; j < WORLD_W/CHUNK_SIZE; j++){
    		chunks[i][j] = calloc(WORLD_Z/CHUNK_SIZE , sizeof(char));
		}
	}
	
	//Mesh data array
	Matrix *sandMeshData = (Matrix*)RL_CALLOC(WORLD_W * WORLD_H * WORLD_Z, sizeof(Matrix));
	int mCount;

	char f[4];
	int k, l;
	int init_update = 1;
	
	InitWindow(screenWidth, screenHeight, "Sand Simulation");

	Camera camera = { 0 };
    camera.position = (Vector3){ 0.0f, 2.0f, 0.0f }; // Camera position
    camera.target = (Vector3){ 10.0f, 2.0f, 0.0f };      // Camera looking at point
	camera.up = (Vector3){ 0.0f, 1.0f, 0.0f };          // Camera up vector (rotation towards target)
   	camera.fovy = 45.0f;                                // Camera field-of-view Y
    camera.projection = CAMERA_PERSPECTIVE;             // Camera projection type

	//Mesh cube = GenMeshPlane(blockSize, blockSize, 1, 1);
	Mesh cube = GenMeshCube(blockSize, blockSize, blockSize);

	// Load lighting shader
    Shader shader = LoadShader(TextFormat("resources/lighting_instancing.vs", GLSL_VERSION),
                               TextFormat("resources/lighting.fs", GLSL_VERSION));
    // Get shader locations
    shader.locs[SHADER_LOC_MATRIX_MVP] = GetShaderLocation(shader, "mvp");
    shader.locs[SHADER_LOC_VECTOR_VIEW] = GetShaderLocation(shader, "viewPos");
    shader.locs[SHADER_LOC_MATRIX_MODEL] = GetShaderLocationAttrib(shader, "instanceTransform");

    // Set shader value: ambient light level
    int ambientLoc = GetShaderLocation(shader, "ambient");
    SetShaderValue(shader, ambientLoc, (float[4]){ 0.2f, 0.2f, 0.2f, 1.0f }, SHADER_UNIFORM_VEC4);

    // Create one light
    CreateLight(LIGHT_DIRECTIONAL, (Vector3){ 50.0f, 50.0f, 0.0f }, Vector3Zero(), WHITE, shader);
	CreateLight(LIGHT_DIRECTIONAL, (Vector3){ 0.0f, 50.0f, 50.0f }, Vector3Zero(), WHITE, shader);


    // NOTE: We are assigning the intancing shader to material.shader
    // to be used on mesh drawing with DrawMeshInstanced()
    Material matDefault = LoadMaterialDefault();
    matDefault.shader = shader;
    matDefault.maps[MATERIAL_MAP_DIFFUSE].color = YELLOW;


	//Material matDefault = LoadMaterialDefault();
	//matDefault.maps[MATERIAL_MAP_DIFFUSE].color = GREEN;


    

	rainBrush(grid, chunks);
	//grid[0][0][0] = 2;
	//grid[0][100][0] = 2;

	mCount = calcMesh3D(blockSize, grid, 0, 0, 0, WORLD_W, WORLD_H, WORLD_Z, cube, matDefault, sandMeshData);	

	while(!WindowShouldClose()){

		UpdateCamera(&camera, CAMERA_FIRST_PERSON);
		
		float cameraPos[3] = { camera.position.x, camera.position.y, camera.position.z };
        SetShaderValue(shader, shader.locs[SHADER_LOC_VECTOR_VIEW], cameraPos, SHADER_UNIFORM_VEC3);
		
		BeginDrawing();
		
		if(IsKeyDown(49)){
			brushMode = 1;
		}
		if(IsKeyDown(50)){
			brushMode = 2;
		}
		if(IsKeyDown(51)){
			brushMode = 3;
		}
		
		ClearBackground(WHITE);
		

		//3D Drawing Chunks
		BeginMode3D(camera);

            DrawCube((Vector3){0, 0, 0}, 2.0f, 2.0f, 2.0f, RED);
			DrawCube((Vector3){3, 0, 0}, 1.0f, 1.0f, 0.5f, BLUE);
            DrawGrid(50, 1.0f);
			//DrawMeshInstanced(cube, matDefault, transforms, 1000);

		#pragma omp parallel
		{
			int t = omp_get_thread_num();
			int tcnt = omp_get_num_threads();
			for(int u = WORLD_H / CHUNK_SIZE - 1; u >= 0; u--){
				for(int v = 0; v < WORLD_W/CHUNK_SIZE; v++){
					for(int w = t; w < WORLD_Z/CHUNK_SIZE; w+=tcnt){
						if(chunks[u][v][w] == 1){
							//DrawCube((Vector3){v * CHUNK_SIZE * 0.2 + (CHUNK_SIZE * 0.2 * 0.5), u  * chunkSize * 0.4 + (CHUNK_SIZE * 0.2 * 0.5), w*chunkSize*0.2 + (CHUNK_SIZE * 0.2 * 0.5)}, CHUNK_SIZE * 0.2, CHUNK_SIZE * 0.2, CHUNK_SIZE * 0.2, (Color){255, 0, 0, 30});
							updateGrid(v, u, w, WORLD_W, WORLD_H, WORLD_Z, grid, chunks);
							
							init_update = 1;
							
						}
							
					}
							
				}
			}
			
				
		}
		if(init_update == 1){
			mCount = calcMesh3D(blockSize, grid, 0, 0, 0, WORLD_W, WORLD_H, WORLD_Z, cube, matDefault, sandMeshData);
			init_update = 0;
		}
		DrawMeshInstanced(cube, matDefault, sandMeshData, mCount);
        EndMode3D();

		//printf("%d\n", grid[0][0][0]);
		
		if(brushMode == 1){
			DrawText("Block Brush", 10, 10, 10, RED);
		}
		if(brushMode == 2){
			DrawText("Sand Brush", 10, 10, 10, RED);
		}
		if(brushMode == 3){
			DrawText("Water Brush", 10, 10, 10, RED);
		}
		

		//Display FPS
		sprintf(f, "%d", GetFPS());
		DrawText(f, 10, 20, 10, RED);
		
		EndDrawing();
	}
	RL_FREE(sandMeshData);
	return 0;
}
